var app = angular.module('alarmviewer', ['ngTouch', 'ngAnimate', 'pascalprecht.translate']);

app.config(function($translateProvider){
    $translateProvider.useStaticFilesLoader({
        prefix: '/locale/locale-',
        suffix: '.json'
    });
    $translateProvider.preferredLanguage('fr');
});

// Notification system
app.run(function($rootScope, $timeout, $translate){

    /* For now, there is no way of asking angular-translate-loader what 
    languages are available */
    $rootScope.languages = ['fr', 'en'];

    var language = localStorage.getItem('language');
    if (language){
        $translate.use(language);
    } else {
        language = navigator.language || navigator.userLanguage;
        if (language.substr(0, 2) == "fr"){
            $translate.use("fr");
        } else {
            $translate.use("en");
        }
    }

    $rootScope.changeLanguage = function(langKey){
        $translate.use(langKey);
        localStorage.setItem('language', langKey);
    };

    $rootScope.getCurrentLanguage = function(){
        return $translate.use() || $translate.proposedLanguage();
    }

    $rootScope.notification = {
        message: "",
        show: false,
        timeout: undefined,
        priority: 0
    };

    /**
     * Function called by any controller when it needs to display a notification
     * @param message The message to be displayed
     * @param autoHide if set to true, the notification is hidden after 5s
     * @param priority if a new notification is sent when one is already being displayed, the new one will be shown only if its priority is higher or equal
     * @param params Used for dynamic translations
     */
    $rootScope.sendnotification = function(message, autoHide, priority, params){
        if ($rootScope.notification.show && $rootScope.notification.priority > priority){
            return;
        }
        if ($rootScope.notification.timeout){
            $timeout.cancel($rootScope.notification.timeout);
            $rootScope.notification.timeout = undefined;
        }
        $rootScope.notification.message = message;
        $rootScope.notification.priority = priority;
        $rootScope.notification.show = true;
        $rootScope.notification.params = params;
        
        if (autoHide){
            $rootScope.notification.timeout = $timeout(function(){
                $rootScope.notification.show = false;
                $rootScope.notification.timeout = undefined;
            }, 5000);
        }
    };

    $rootScope.hidenotification = function(){
        $rootScope.notification.show = false;
        $timeout.cancel($rootScope.notification.timeout);
        $rootScope.notification.timeout = undefined;
    };

    /**
      * Helper function to log http error messages
    **/
    $rootScope.logHttpError = function(httpResponse){
        var errorMsg = "Error : " + 
            httpResponse.config.method + " " + httpResponse.config.url
        + "\nCode " + httpResponse.status 
        + " - " + httpResponse.statusText
        + " : " 
        + httpResponse.data;
        console.error(errorMsg);
    }

    $rootScope.help = false;
    $rootScope.$watch('help', function(newVal, oldVal){
        console.log(newVal)
    })

});


app.animation('.notif-animation', function (){
    return {
        addClass: function (element, className, done) {
            var scope = element.scope();

            if (className == 'ng-hide'){
                element.slideUp(done);
            }
            else {
                done();
            }
        },
        removeClass: function (element, className, done) {
            var scope = element.scope();

            if (className == 'ng-hide') {
                element.removeClass('ng-hide');
                element.slideDown(done);
            }
            else {
                done();
            }
        }
    };
});


function getClientDevice(){

    var tabletBreakpoint = 992;
    var mobileBreakpoint = 768;
    var viewportWidth = document.documentElement.clientWidth;

    if (viewportWidth < mobileBreakpoint){
        return 'mobile';
    } else if (viewportWidth < tabletBreakpoint){
        return 'tablet';
    } else {
        return 'desktop';
    }

}

// This whole system is not clean and could be replaced by css classes (hidden-*), but it has the advantage
// of allowing us to use angular's ng-if to show/hide some elements (much more efficient for big HTML pages)
var device = getClientDevice();
app.value('device', device);
angular.element(window).bind("resize", function(){
    var deviceUpdated = getClientDevice();
    if (deviceUpdated !== device){
        setTimeout(function(){
            location.reload();
        }, 0);
    }
});

app.directive('spinner', function(){
    return {
        restrict: 'E',
        replace: true,
        template: '<div class="spinner">',
        link: function(scope, elem, attrs){
            var options = {
                lines: 12,
                length: 12,
                corners: 1,
                radius: 12,
                rotate: 0,
                direction: 1,
                speed: 1,
                trail: 50,
                color: 'red',
                opacity: 0.25,
                direction: 1,
                speed: 1
            };
            var target = elem[0];
            var wheel = new Spinner(options).spin(target);
        }
    }
});
function LoadImages(httpService, alarm, cb)
{
    if (!alarm.hasOwnProperty("Images")) {
        alarm.Images = [];
        var counter = 0;
        var dataLoaded = function () {            
            if (++counter == 2 * alarm.nbimages) cb();
        };

        for (var i = 0; i < alarm.nbimages; i++) {
            alarm.Images[i] = { Image : new Image() };
            alarm.Images[i].Image.addEventListener("load", dataLoaded);
            alarm.Images[i].Image.src = "/alarms/" + alarm.id + "/image/"+i+"/jpg";

            httpService.get("/alarms/" + alarm.id + "/image/" + i + "/osd").success(function (idx) {
                return function (data) {
                    alarm.Images[idx].OSD = data;                    
                    dataLoaded();
                };
            }(i)).error(dataLoaded);
        }        
    }
    else
        cb();
}


app.factory('alarmevents', ['$rootScope',
    function ($rootScope) {
        var source = new EventSource("/events");
        var eventForwarder = function (e) {
            var jData = null;
            try { jData = JSON.parse(e.data); } catch (err) { }

            if (jData)
                $rootScope.$apply($rootScope.$emit.bind($rootScope, e.type, jData));
        };
        
        source.addEventListener('alarm_create', eventForwarder, false);
        source.addEventListener('alarm_update', eventForwarder, false);
        source.addEventListener('alarm_deleted', eventForwarder, false);
        source.addEventListener('connection', eventForwarder, false);
        
        return source;
    }
]);
; (function (global) {
    //cf https://github.com/remy/polyfills/blob/master/EventSource.js   
    if ("EventSource" in global) return;
    
    var reTrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
    
    var EventSource = function (url) {
        var eventsource = this,  
            interval = 500, // polling interval  
            lastEventId = null,
            cache = '';
        
        if (!url || typeof url != 'string') {
            throw new SyntaxError('Not enough arguments');
        }
        
        this.URL = url;
        this.readyState = this.CONNECTING;
        this._pollTimer = null;
        this._xhr = null;
        
        function pollAgain(interval) {
            eventsource._pollTimer = setTimeout(function () {
                poll.call(eventsource);
            }, interval);
        }
        
        function poll() {
            try { // force hiding of the error message... insane?
                if (eventsource.readyState == eventsource.CLOSED) return;
                
                // NOTE: IE7 and upwards support
                var xhr = new XMLHttpRequest();
                xhr.open('GET', eventsource.URL, true);
                xhr.setRequestHeader('Accept', 'text/event-stream');
                xhr.setRequestHeader('Cache-Control', 'no-cache');
                // we must make use of this on the server side if we're working with Android - because they don't trigger 
                // readychange until the server connection is closed
                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                
                if (lastEventId != null) xhr.setRequestHeader('Last-Event-ID', lastEventId);
                cache = '';
                
                xhr.timeout = 50000;
                xhr.onreadystatechange = function () {
                    if (this.readyState == 3 || (this.readyState == 4 && this.status == 200)) {
                        // on success
                        if (eventsource.readyState == eventsource.CONNECTING) {
                            eventsource.readyState = eventsource.OPEN;
                            eventsource.dispatchEvent('open', { type: 'open' });
                        }
                        
                        var responseText = '';
                        try {
                            responseText = this.responseText || '';
                        } catch (e) { }
                        
                        // process this.responseText
                        var parts = responseText.substr(cache.length).split("\n"),
                            eventType = 'message',
                            data = [],
                            i = 0,
                            line = '';
                        
                        cache = responseText;
                        
                        // TODO handle 'event' (for buffer name), retry
                        for (; i < parts.length; i++) {
                            line = parts[i].replace(reTrim, '');
                            if (line.indexOf('event') == 0) {
                                eventType = line.replace(/event:?\s*/, '');
                            } else if (line.indexOf('retry') == 0) {
                                retry = parseInt(line.replace(/retry:?\s*/, ''));
                                if (!isNaN(retry)) { interval = retry; }
                            } else if (line.indexOf('data') == 0) {
                                data.push(line.replace(/data:?\s*/, ''));
                            } else if (line.indexOf('id:') == 0) {
                                lastEventId = line.replace(/id:?\s*/, '');
                            } else if (line.indexOf('id') == 0) { // this resets the id
                                lastEventId = null;
                            } else if (line == '') {
                                if (data.length) {
                                    var event = new MessageEvent(data.join('\n'), eventsource.url, lastEventId);
                                    eventsource.dispatchEvent(eventType, event);
                                    data = [];
                                    eventType = 'message';
                                }
                            }
                        }
                        
                        if (this.readyState == 4) pollAgain(interval);
          // don't need to poll again, because we're long-loading
                    } else if (eventsource.readyState !== eventsource.CLOSED) {
                        if (this.readyState == 4) { // and some other status
                            // dispatch error
                            eventsource.readyState = eventsource.CONNECTING;
                            eventsource.dispatchEvent('error', { type: 'error' });
                            pollAgain(interval);
                        } else if (this.readyState == 0) { // likely aborted
                            pollAgain(interval);
                        } else {
                        }
                    }
                };
                
                xhr.send();
                
                setTimeout(function () {
                    if (true || xhr.readyState == 3) xhr.abort();
                }, xhr.timeout);
                
                eventsource._xhr = xhr;
    
            } catch (e) { // in an attempt to silence the errors
                eventsource.dispatchEvent('error', { type: 'error', data: e.message }); // ???
            }
        }        ;
        
        poll(); // init now
    };
    
    EventSource.prototype = {
        close: function () {
            // closes the connection - disabling the polling
            this.readyState = this.CLOSED;
            clearInterval(this._pollTimer);
            this._xhr.abort();
        },
        CONNECTING: 0,
        OPEN: 1,
        CLOSED: 2,
        dispatchEvent: function (type, event) {
            var handlers = this['_' + type + 'Handlers'];
            if (handlers) {
                for (var i = 0; i < handlers.length; i++) {
                    handlers[i].call(this, event);
                }
            }
            
            if (this['on' + type]) {
                this['on' + type].call(this, event);
            }
        },
        addEventListener: function (type, handler) {
            if (!this['_' + type + 'Handlers']) {
                this['_' + type + 'Handlers'] = [];
            }
            
            this['_' + type + 'Handlers'].push(handler);
        },
        removeEventListener: function (type, handler) {
            var handlers = this['_' + type + 'Handlers'];
            if (!handlers) {
                return;
            }
            for (var i = handlers.length - 1; i >= 0; --i) {
                if (handlers[i] === handler) {
                    handlers.splice(i, 1);
                    break;
                }
            }
        },
        onerror: null,
        onmessage: null,
        onopen: null,
        readyState: 0,
        URL: ''
    };
    
    var MessageEvent = function (data, origin, lastEventId) {
        this.data = data;
        this.origin = origin;
        this.lastEventId = lastEventId || '';
    };
    
    MessageEvent.prototype = {
        data: null,
        type: 'message',
        lastEventId: '',
        origin: ''
    };
    
    if ('module' in global) module.exports = EventSource;
    global.EventSource = EventSource;
 
})(this);
app.controller('accountController', ["$scope", '$rootScope', '$window', 'device', 'userdb', '$translate', '$timeout', function($scope, $rootScope, $window, device, userdb, $translate, $timeout) {
    
    $scope.device = device;
    $scope.showMenu = true;
    $scope.user = {};
    $scope.password = {
        old: '',
        new: '',
        confirm: ''
    };
    $scope.tab = 'loginForm';

    $scope.currentLanguage = $scope.getCurrentLanguage();

    $scope.onLanguageChange = function(){
        $scope.changeLanguage($scope.currentLanguage);
    };

    userdb.getCurrentUser(function success(response){
            $scope.user = response.data;
        }, function error(response){
            $scope.logHttpError(response);
            $scope.sendnotification("NOTIF_ERROR_GETTING_ACCOUNT_INFO", 
                    false,
                    1);
    });

    $scope.commituser = function(){
        userdb.updateDisplayName($scope.user.displayname, function success(resopnse){
            $scope.sendnotification("NOTIF_NAME_CHANGED", true, 1);
        }, function error(response){
            $scope.sendnotification("NOTIF_ERROR_UPDATING_USER_INFO", 
                false, 1);
            $scope.logHttpError(response);
        });
    };


    $scope.changepassword = function(){
        if ($scope.password.new === $scope.password.confirm){
            userdb.changePassword($scope.password.old, $scope.password.new, function success(response){
                $scope.sendnotification("NOTIF_PASSWORD_CHANGED", true, 1);
                $timeout(function(){
                    $window.location.href = '/';
                },3000);
            }, function error(response){
                if (response.status === 401){
                    $scope.sendnotification("NOTIF_INCORRECT_PASSWORD", false, 1);
                } else {
                    $scope.sendnotification("NOTIF_ERROR_UPDATING_PASSWORD", false, 1);
                }
                $scope.logHttpError(response);
            });
        } else {
            $scope.sendnotification("NOTIF_ERROR_PASSWORD_FIELDS_DONT_MATCH", false, 1);
        }
    };

}]);













app.factory('alarmdb', ['$http','$rootScope', function($http, $rootScope){
    	
    var obj={};

    obj.getSiteList = function(success, error){
        $http.get("/alarms/sitelist")
            .then(success, error);
    };

    obj.getCameraList = function(success, error){
        $http.get("/alarms/cameralist")
            .then(success, error);
    };
    			
	obj.getAlarms = function(conditions, success, error){
        var params = '';
        if (Object.keys(conditions).length > 0){
            params += '?';
            params += 'date=' + conditions.date.getTime() / 1000;
            if (conditions.sitename !== 'all'){
                params += '&sitename=' + conditions.sitename.replace(' ', '%20');
                if (conditions.camera !== 'all'){
                    // conditions.camera = { cameraname: **, sitename: ** }
                    params += '&cameraname=' + conditions.camera.replace(' ', '%20');
                }
            }
        }
		$http.get("/alarms" + params)
			.then(success, error);
    };

    obj.getNotHandledAlarms = function(success, error){
        $http.get("/alarms?handled=0")
            .then(success, error);
    };
        
    obj.markashandled = function (alarmid, success, error) {
        $http.put("/alarms/"+alarmid+"/handled")
		  .then(success, error);
    };

    return obj;

}]);



app.controller('tabcontroller', ["$scope", function($scope){
    $scope.tab = 'notHandled';
}]);


app.controller('alarmcontroller', ["$scope", '$rootScope', '$window', "alarmdb", 'alarmevents', 'device', '$window', '$translate', function($scope, $rootScope, $window, alarmdb, alarmevents, device, $window, $translate) {

    $scope.device = device;

    $scope.sortType = 'timestamp';
    $scope.sortReverse = true;

    $scope.currentalarm = undefined;
    $scope.selected = [];

    $scope.loading = true; // Displays loading wheel

    // We don't want to display all alarms at once, loading is too long
    var initialNbDisplayedAlarms = 20;
    var stepShowMoreAlarms = 20;
    $scope.limit = initialNbDisplayedAlarms;
    $scope.showmorealarms = function(){
        $scope.limit += stepShowMoreAlarms;
    };

    alarmdb.getSiteList(function success(response){
        console.log('Site list', response)
        $scope.sites = response.data;
    }, function error(response){
        $scope.logHttpError(response);
        $scope.sendnotification("NOTIF_ERROR_GETTING_SITE_LIST", false, 1);
    });

    alarmdb.getCameraList(function success(response){
        $scope.cameras = response.data;
    }, function error(response){
        $scope.logHttpError(response);
        $scope.sendnotification("NOTIF_ERROR_GETTING_CAMERA_LIST", false, 1);     
    });


    // Filters
    var today = new Date();
    today.setHours(0, 0, 0, 0);

    $scope.filters = {
        sitename: 'all',
        camera: 'all',
        date: today
    };
    $scope.showfilters = false;
    // Stores current values, enables an easy form reset
    $scope.currentfilters = angular.copy($scope.filters);

    // Reset camera filter to 'all' when site is changed
    $scope.$watch('filters.sitename', function(newVal, oldVal){
        if (newVal !== oldVal){
            $scope.filters.camera = 'all';
        }
    });

    $scope.applyfilters = function(){
        if (!$scope.filters.date){
            $scope.sendnotification("NOTIF_INVALID_DATE_FORMAT", false, 1);
            return false;
        }
        $scope.loading = true;
        $scope.showfilters = false;
        $scope.limit = initialNbDisplayedAlarms; // Don't show all alarms at once
        $scope.currentalarm = undefined;
        $scope.currentfilters = angular.copy($scope.filters);
        alarmdb.getAlarms($scope.filters, function success(response){
            $scope.alarms = response.data;
            $scope.loading = false;
        }, function error(response){
            $scope.logHttpError(response);
            $scope.sendnotification("NOTIF_ERROR_GETTING_ALARMS", false, 1);
        });
    };

    $scope.resetfilters = function(){
        $scope.showfilters = false;
        $scope.filters = angular.copy($scope.currentfilters);
    };


    //  *** GETTING ALARMS LISTS ***
    // When this is executed (on page load), ng-init hasn't been run, 
    // so we don't know which tab we're working in yet
    $scope.cancelTabWatcher = $scope.$watch('tabName', function(newVal, oldVal){
        $scope.getAlarms();
    });

    $scope.getAlarms = function(){
        // ng-init has been run, stop watching tab changes
        $scope.cancelTabWatcher();

        if ($scope.tabName === 'notHandled'){

            alarmdb.getNotHandledAlarms(function success(response){
                $scope.alarms = response.data;
                $scope.loading = false;
            }, function error(response){
                $scope.logHttpError(response);
                $scope.sendnotification("NOTIF_ERROR_GETTING_ALARMS", false, 1);
            });

        } else if ($scope.tabName === 'filteredAlarms'){

            alarmdb.getAlarms($scope.filters, function success(response){
                $scope.alarms = response.data;
                $scope.loading = false;
            }, function error(response){
                $scope.logHttpError(response);
                $scope.sendnotification("NOTIF_ERROR_GETTING_ALARMS", false, 1);
            });

        }
    };

    $scope.playalarm = function(alarmid){

        // Mobile devices : if the user clicked on alarm while the filter pop-up was visible, make sure that it is hidden when going back to alarm list
        $scope.showfilters = false;
        $scope.resetfilters();

        var pos = $scope.alarms.map(function(e){ return e.id; }).indexOf(alarmid);
        var selectedAlarm = (pos==-1) ? undefined : $scope.alarms[pos];

        // if (selectedAlarm.nbimages > 0){
            $scope.currentalarm = selectedAlarm;
        // }
        
    };
        

    $scope.markashandled = function (alarmId, $event){
        if (($scope.currentalarm !== undefined && $scope.currentalarm.id == alarmId) || $window.confirm($translate.instant("CONFIRM_HANDLE_ALARM"))) {
            if ($scope.currentalarm !== undefined && $scope.currentalarm.id == alarmId){
                var previousAlarm = $scope.getPreviousDisplayedAlarm();
                if (previousAlarm !== -1){
                    $scope.currentalarm = $scope.displayedalarms[previousAlarm];
                } else {
                    $scope.currentalarm = undefined; // No more alarms to show
                }
            }
            alarmdb.markashandled(alarmId, function success(resopnse){ 

            }, function error(response){
                $scope.logHttpError(response);
                $scope.sendnotification("NOTIF_ERROR_MARK_HANDLED", false, 1);
            });
        }
        $event.stopPropagation();
    };


    $scope.markcurrentashandled = function($event){
        $scope.markashandled($scope.currentalarm.id, $event);
    };

    // Used by swuper
    $scope.shownextalarm = function(){
        var nextAlarm = $scope.getNextAlarm();
        if (nextAlarm !== -1){
            var alarmid = $scope.alarms[nextAlarm].id;
            $scope.playalarm(alarmid);
        } else {
            $scope.currentalarm = undefined;
        }
    };

    $scope.showpreviousalarm = function(){
        var previousAlarm = $scope.getPreviousAlarm();
        if (previousAlarm !== -1){
            var alarmid = $scope.alarms[previousAlarm].id;
            $scope.playalarm(alarmid);
        } else {
            $scope.currentalarm = undefined;
        }
    };

    $scope.getNextAlarm = function(){
        if ($scope.alarms.length < 2){
            return -1;
        } else {
            var position = $scope.alarms.map(function(a){ return a.id; }).indexOf($scope.currentalarm.id);
            if (position === $scope.alarms.length - 1){
                return 0;
            } else {
                return position + 1;
            }
        }
    };

    $scope.getPreviousAlarm = function(){
        if ($scope.alarms.length < 2){
            return -1;
        } else {
            var position = $scope.alarms.map(function(a){ return a.id; }).indexOf($scope.currentalarm.id);
            if (position === 0){
                return $scope.alarms.length - 1;
            } else {
                return position - 1;
            }
        }
    };

    // Returns id of next alarm among the displayed alarms (not all alarms + sorted by the user)
    $scope.getNextDisplayedAlarm = function(){
        if ($scope.displayedalarms.length < 2){
            return -1;
        } else {
            var position = $scope.displayedalarms.map(function(a){ return a.id; }).indexOf($scope.currentalarm.id);
            if (position === $scope.displayedalarms.length - 1){
                return 0;
            } else {
                return position + 1;
            }
        }
    };

    $scope.getPreviousDisplayedAlarm = function(){
        if ($scope.displayedalarms.length < 2){
            return -1;
        } else {
            var position = $scope.displayedalarms.map(function(a){ return a.id; }).indexOf($scope.currentalarm.id);
            if (position === 0){
                return $scope.displayedalarms.length - 1;
            } else {
                return position - 1;
            }
        }
    };


    $scope.handleSelected = function(){
        if (window.confirm($translate.instant("CONFIRM_HANDLE_SELECTED"))){
            $scope.selected.forEach(function(id){
                alarmdb.markashandled(id, function success(resopnse){ 

                }, function error(response){
                    $scope.logHttpError(response);
                    $scope.sendnotification("NOTIF_ERROR_MARK_HANDLED", 
                        false, 
                        1);
                });
            });
        }
    };

    $scope.handleall = function(callback){
        // Copy the alarm list to avoid handling new alarms
        var alarms = [];
        $scope.alarms.forEach(function(a){
            alarms.push(a);
        });
        if ($window.confirm($translate.instant("CONFIRM_HANDLE_ALL"))){
            alarms.forEach(function(a){
                alarmdb.markashandled(a.id, function success(resopnse){ 

                }, function error(response){
                    $scope.logHttpError(response);
                    $scope.sendnotification("NOTIF_ERROR_MARK_HANDLED", 
                        false, 
                        1);
                });
            });
            $scope.currentalarm = undefined;
        }
    };

    $scope.isSelected = function(id){
        return $scope.selected.indexOf(id) >= 0;
    };

    $scope.updateSelection = function(id, event){
        event.stopPropagation();
        if($scope.isSelected(id)){
            $scope.selected.splice($scope.selected.indexOf(id), 1);
        } else {
            $scope.selected.push(id);
        }
    };

    $scope.selectall = function(){
        if ($scope.selected.length == $scope.displayedalarms.length){
            $scope.selected = [];
        } else {
            $scope.displayedalarms.forEach(function(a){
                if ($scope.selected.indexOf(a.id) < 0 && a.handled === 0){
                    $scope.selected.push(a.id);
                }
            });
        }
    };

    // Used in filter select input
    // Gets the cameras for the currently selected site
    $scope.camerasForCurrentSite = function(camera){
        if (camera === 'all'){
            return true;
        } else {
            var index = $scope.cameras.map(function(c){ return c.cameraname }).indexOf(camera.sitename);
            return $scope.cameras[index].sitename === $scope.filters.sitename;
        }
    };


    $scope.getNotHandledAlarms = function(){
        if ($scope.alarms){
            return $scope.alarms.filter(function(a){
                return a.handled === 0;
            });
        } else {
            return [];
        }
    };


    // Alarm updates from server
    var alarmUpdate = function(event, data){
		var pos = $scope.alarms.map(function(e) { return e.id; }).indexOf(data.id);
        if (pos >= 0){

            // Current alarm was markes as handled by another client
            if ($scope.currentalarm !== undefined 
                    && $scope.currentalarm.id == data.id 
                    && data.handled != 0){
                $window.alert($translate.instant("CONFIRM_HANDLED"));
                $scope.currentalarm = undefined;
            }

            if ($scope.tabName === 'notHandled' && data.handled != 0){
                $scope.alarms.splice(pos, 1);
            } else {
                $scope.alarms[pos] = data;
            }

            if ($scope.selected.indexOf(data.id) >= 0){
                $scope.selected.splice($scope.selected.indexOf(data.id), 1);
            }
        } else {
            $scope.limit++;
            if ($scope.tabName === 'notHandled'){
                $scope.alarms.push(data);
            }
        }
		
	};

    var unbind1 = $rootScope.$on("alarm_create", alarmUpdate);
    var unbind2 = $rootScope.$on("alarm_update", alarmUpdate);

    $scope.$on('$destroy', function () { unbind1(); unbind2(); });

}]);



app.directive('swiper', function(){

    return {
        templateUrl: '/swiper',
        restrict: 'E',
        replace: true
    };

});

app.directive('imagewithosd', function(){
    return {
        restrict: 'E',
        scope:{image:"=", osd:"="},
        replace: true,
        template: '<canvas class="imagecanvas"/>',
        link: function(scope, elem, attrs){

            var canvas = elem[0];
            canvas.setAttribute('width', 800);
            canvas.setAttribute('height', 600);

            function repaintImage(){

                var ctx = canvas.getContext("2d");
                ctx.width = 800;
                ctx.height = 600;

                if (scope.image && scope.image.naturalWidth && scope.image.naturalWidth > 0 && scope.image.naturalHeight > 0){

                    var hRatio = ctx.width / scope.image.naturalWidth;
                    var vRatio = ctx.height / scope.image.naturalHeight;
                    var ratio = Math.min(hRatio, vRatio);
                    var shiftX = (ctx.width - scope.image.naturalWidth * ratio) / 2;
                    var shiftY = (ctx.height - scope.image.naturalHeight * ratio) / 2;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(scope.image, 0, 0, scope.image.naturalWidth, scope.image.naturalHeight,
                                                shiftX, shiftY, scope.image.naturalWidth * ratio, scope.image.naturalHeight * ratio);

                    if (scope.osd){
                        for (var i = 0; i < scope.osd.length; i++) {
                            var points = scope.osd[i];
                            
                            ctx.lineWidth = "2";
                            ctx.strokeStyle = "red";

                            ctx.beginPath();
                            ctx.moveTo(points[0].x * canvas.width / scope.image.width, points[0].y * canvas.height / scope.image.height);
                            for (var j = 0; j < points.length; j++)
                                ctx.lineTo(points[j].x * canvas.width / scope.image.width, points[j].y * canvas.height / scope.image.height);
                            ctx.closePath();
                            ctx.stroke();
                        }

                    }

                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }

            }
              
            scope.$watch('image', function(newVal, oldVal){
                repaintImage();
            });
            scope.$watch('osd', function(newVal, oldVal){
                repaintImage();
            });

        }

    };
});

app.directive('imageplayer', ["$http","$interval", "$timeout", function($http, $interval, $timeout) {
  return {
	  restrict: 'E',
	  scope:{alarm:"=", imgwidth:"@", imgheight:"@", help: "="},
	  replace: true,
	  templateUrl: '/imageplayer',
	  link: function(scope, elem, attrs){
            scope.rootElement = elem;
            scope.loading = false;
            scope.currentIdx = 0;
            scope.showOsd = true;
            scope.playing = false;
            scope.showcontrols = true;
            scope.interval;

            scope.toggleOsd = function () {
                scope.showOsd = !scope.showOsd;
            };

            scope.nextImage = function (){
                if(scope.alarm && scope.alarm.nbimages)
                    // scope.currentIdx = 1;
                    scope.currentIdx = (scope.currentIdx + 1) % scope.alarm.nbimages;
            };

            scope.prevImage = function (){
                if (scope.alarm && scope.alarm.nbimages)
                    scope.currentIdx = (scope.currentIdx - 1 + scope.alarm.nbimages) % scope.alarm.nbimages;
            };

            scope.$watch('playing', function(newVal, oldVal){
                if (newVal === oldVal) return;
                if (newVal){
                    scope.interval = $interval(function () { 
                        scope.nextImage();
                    }, 500);
                } else {
                    $interval.cancel(scope.interval);
                }
            });
		  
            scope.$watch('alarm', function (newVal, oldVal){
                if (newVal === oldVal) return;
                if (!newVal) return;
                scope.playing = true;
                scope.loading = true;
                LoadImages($http, newVal, function () {
                    $timeout(function () {
                        scope.loading = false;
                        // Find the first image with OSD
                        var firstImageWithOSD = 0;
                        scope.alarm.Images.some(function(img, index){
                            if (img.OSD && img.OSD.length > 0){
                                firstImageWithOSD = index;
                                return true;
                            } else {
                                return false;
                            }
                        }); 
                        scope.currentIdx = firstImageWithOSD - 1;
                        scope.nextImage();
                    }, 0);
                });
            });

        }

    };
}]);













app.factory('appstate', function(){

    var obj = {};

    obj.saveState = function(key, value){
        localStorage.setItem(key, value);
    };

    obj.getState = function(key){
        return parseInt(localStorage.getItem(key));
    };

    return obj;

});
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.async=t.async||{})}(this,function(t){"use strict";function n(t,n,r){var e=r.length;switch(e){case 0:return t.call(n);case 1:return t.call(n,r[0]);case 2:return t.call(n,r[0],r[1]);case 3:return t.call(n,r[0],r[1],r[2])}return t.apply(n,r)}function r(t){var n=typeof t;return!!t&&("object"==n||"function"==n)}function e(t){var n=r(t)?hr.call(t):"";return n==lr||n==sr}function o(t){return!!t&&"object"==typeof t}function u(t){return"symbol"==typeof t||o(t)&&dr.call(t)==vr}function i(t){if("number"==typeof t)return t;if(u(t))return gr;if(r(t)){var n=e(t.valueOf)?t.valueOf():t;t=r(n)?n+"":n}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(mr,"");var o=_r.test(t);return o||jr.test(t)?wr(t.slice(2),o?2:8):br.test(t)?gr:+t}function c(t){if(!t)return 0===t?t:0;if(t=i(t),t===Sr||t===-Sr){var n=0>t?-1:1;return n*Or}return t===t?t:0}function a(t){var n=c(t),r=n%1;return n===n?r?n-r:n:0}function f(t,r){if("function"!=typeof t)throw new TypeError(kr);return r=Er(void 0===r?t.length-1:a(r),0),function(){for(var e=arguments,o=-1,u=Er(e.length-r,0),i=Array(u);++o<u;)i[o]=e[r+o];switch(r){case 0:return t.call(this,i);case 1:return t.call(this,e[0],i);case 2:return t.call(this,e[0],e[1],i)}var c=Array(r+1);for(o=-1;++o<r;)c[o]=e[o];return c[r]=i,n(t,this,c)}}function l(t){return f(function(n){var r=n.pop();t.call(this,n,r)})}function s(t){return f(function(n,r){var e=l(function(r,e){var o=this;return t(n,function(t,n){t.apply(o,r.concat([n]))},e)});return r.length?e.apply(this,r):e})}function p(){}function h(t){return function(){if(null!==t){var n=t;t=null,n.apply(this,arguments)}}}function v(t){return function(n){return null==n?void 0:n[t]}}function y(t){return"number"==typeof t&&t>-1&&t%1==0&&Lr>=t}function d(t){return null!=t&&y(Ar(t))&&!e(t)}function g(t){return xr&&t[xr]&&t[xr]()}function m(t){return Ir(Object(t))}function b(t,n){return Mr.call(t,n)||"object"==typeof t&&n in t&&null===m(t)}function _(t){return $r(Object(t))}function j(t,n){for(var r=-1,e=Array(t);++r<t;)e[r]=n(r);return e}function w(t){return o(t)&&d(t)}function S(t){return w(t)&&Pr.call(t,"callee")&&(!Br.call(t,"callee")||Dr.call(t)==zr)}function O(t){return"string"==typeof t||!Ur(t)&&o(t)&&qr.call(t)==Cr}function k(t){var n=t?t.length:void 0;return y(n)&&(Ur(t)||O(t)||S(t))?j(n,String):null}function E(t,n){return n=null==n?Wr:n,!!n&&("number"==typeof t||Nr.test(t))&&t>-1&&t%1==0&&n>t}function A(t){var n=t&&t.constructor,r="function"==typeof n&&n.prototype||Vr;return t===r}function L(t){var n=A(t);if(!n&&!d(t))return _(t);var r=k(t),e=!!r,o=r||[],u=o.length;for(var i in t)!b(t,i)||e&&("length"==i||E(i,u))||n&&"constructor"==i||o.push(i);return o}function x(t){var n,r=-1;if(d(t))return n=t.length,function(){return r++,n>r?{value:t[r],key:r}:null};var e=g(t);if(e)return function(){var t=e.next();return t.done?null:(r++,{value:t.value,key:r})};var o=L(t);return n=o.length,function(){r++;var e=o[r];return n>r?{value:t[e],key:e}:null}}function I(t){return function(){if(null===t)throw new Error("Callback was already called.");var n=t;t=null,n.apply(this,arguments)}}function T(t){return function(n,r,e){e=h(e||p),n=n||[];var o=x(n);if(0>=t)return e(null);var u=!1,i=0,c=!1;!function a(){if(u&&0>=i)return e(null);for(;t>i&&!c;){var n=o();if(null===n)return u=!0,void(0>=i&&e(null));i+=1,r(n.value,n.key,I(function(t){i-=1,t?(e(t),c=!0):a()}))}}()}}function M(t){return function(n,r,e,o){return t(T(r),n,e,o)}}function $(t,n,r,e){e=h(e||p),n=n||[];var o=d(n)||g(n)?[]:{};t(n,function(t,n,e){r(t,function(t,r){o[n]=r,e(t)})},function(t){e(t,o)})}function z(t,n){return function(r,e,o){return t(r,n,e,o)}}function F(t){return l(function(n,e){var o;try{o=t.apply(this,n)}catch(u){return e(u)}r(o)&&"function"==typeof o.then?o.then(function(t){e(null,t)})["catch"](function(t){e(t.message?t:new Error(t))}):e(null,o)})}function P(t,n){for(var r=-1,e=t.length;++r<e&&n(t[r],r,t)!==!1;);return t}function D(t){return function(n,r,e){for(var o=-1,u=Object(n),i=e(n),c=i.length;c--;){var a=i[t?c:++o];if(r(u[a],a,u)===!1)break}return n}}function B(t,n){return t&&Yr(t,n,L)}function U(){this.__data__=[]}function C(t,n){return t===n||t!==t&&n!==n}function R(t,n){for(var r=t.length;r--;)if(C(t[r][0],n))return r;return-1}function q(t){var n=this.__data__,r=R(n,t);if(0>r)return!1;var e=n.length-1;return r==e?n.pop():te.call(n,r,1),!0}function W(t){var n=this.__data__,r=R(n,t);return 0>r?void 0:n[r][1]}function N(t){return R(this.__data__,t)>-1}function V(t,n){var r=this.__data__,e=R(r,t);return 0>e?r.push([t,n]):r[e][1]=n,this}function Q(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function G(){this.__data__=new Q}function H(t){return this.__data__["delete"](t)}function J(t){return this.__data__.get(t)}function K(t){return this.__data__.has(t)}function X(t){var n=!1;if(null!=t&&"function"!=typeof t.toString)try{n=!!(t+"")}catch(r){}return n}function Y(t){if(null!=t){try{return ne.call(t)}catch(n){}try{return t+""}catch(n){}}return""}function Z(t){if(!r(t))return!1;var n=e(t)||X(t)?ce:ee;return n.test(Y(t))}function tt(t,n){var r=t[n];return Z(r)?r:void 0}function nt(){this.__data__=ae?ae(null):{}}function rt(t){return this.has(t)&&delete this.__data__[t]}function et(t){var n=this.__data__;if(ae){var r=n[t];return r===fe?void 0:r}return se.call(n,t)?n[t]:void 0}function ot(t){var n=this.__data__;return ae?void 0!==n[t]:he.call(n,t)}function ut(t,n){var r=this.__data__;return r[t]=ae&&void 0===n?ve:n,this}function it(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function ct(t){return t&&t.Object===Object?t:null}function at(){this.__data__={hash:new it,map:new(Se||Q),string:new it}}function ft(t){var n=typeof t;return"string"==n||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==t:null===t}function lt(t,n){var r=t.__data__;return ft(n)?r["string"==typeof n?"string":"hash"]:r.map}function st(t){return lt(this,t)["delete"](t)}function pt(t){return lt(this,t).get(t)}function ht(t){return lt(this,t).has(t)}function vt(t,n){return lt(this,t).set(t,n),this}function yt(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function dt(t,n){var r=this.__data__;return r instanceof Q&&r.__data__.length==Oe&&(r=this.__data__=new yt(r.__data__)),r.set(t,n),this}function gt(t){this.__data__=new Q(t)}function mt(t){return this.__data__.set(t,ke),this}function bt(t){return this.__data__.has(t)}function _t(t){var n=-1,r=t?t.length:0;for(this.__data__=new yt;++n<r;)this.add(t[n])}function jt(t,n){for(var r=-1,e=t.length;++r<e;)if(n(t[r],r,t))return!0;return!1}function wt(t,n,r,e,o,u){var i=o&Ae,c=t.length,a=n.length;if(c!=a&&!(i&&a>c))return!1;var f=u.get(t);if(f)return f==n;var l=-1,s=!0,p=o&Ee?new _t:void 0;for(u.set(t,n);++l<c;){var h=t[l],v=n[l];if(e)var y=i?e(v,h,l,n,t,u):e(h,v,l,t,n,u);if(void 0!==y){if(y)continue;s=!1;break}if(p){if(!jt(n,function(t,n){return p.has(n)||h!==t&&!r(h,t,e,o,u)?void 0:p.add(n)})){s=!1;break}}else if(h!==v&&!r(h,v,e,o,u)){s=!1;break}}return u["delete"](t),s}function St(t){var n=-1,r=Array(t.size);return t.forEach(function(t,e){r[++n]=[e,t]}),r}function Ot(t){var n=-1,r=Array(t.size);return t.forEach(function(t){r[++n]=t}),r}function kt(t,n,r,e,o,u,i){switch(r){case qe:if(t.byteLength!=n.byteLength||t.byteOffset!=n.byteOffset)return!1;t=t.buffer,n=n.buffer;case Re:return t.byteLength==n.byteLength&&e(new xe(t),new xe(n))?!0:!1;case Me:case $e:return+t==+n;case ze:return t.name==n.name&&t.message==n.message;case Pe:return t!=+t?n!=+n:t==+n;case De:case Ue:return t==n+"";case Fe:var c=St;case Be:var a=u&Te;if(c||(c=Ot),t.size!=n.size&&!a)return!1;var f=i.get(t);return f?f==n:(u|=Ie,i.set(t,n),wt(c(t),c(n),e,o,u,i));case Ce:if(Ne)return Ne.call(t)==Ne.call(n)}return!1}function Et(t,n,r,e,o,u){var i=o&Ve,c=L(t),a=c.length,f=L(n),l=f.length;if(a!=l&&!i)return!1;for(var s=a;s--;){var p=c[s];if(!(i?p in n:b(n,p)))return!1}var h=u.get(t);if(h)return h==n;var v=!0;u.set(t,n);for(var y=i;++s<a;){p=c[s];var d=t[p],g=n[p];if(e)var m=i?e(g,d,p,n,t,u):e(d,g,p,t,n,u);if(!(void 0===m?d===g||r(d,g,e,o,u):m)){v=!1;break}y||(y="constructor"==p)}if(v&&!y){var _=t.constructor,j=n.constructor;_!=j&&"constructor"in t&&"constructor"in n&&!("function"==typeof _&&_ instanceof _&&"function"==typeof j&&j instanceof j)&&(v=!1)}return u["delete"](t),v}function At(t){return eo.call(t)}function Lt(t){return o(t)&&y(t.length)&&!!Fo[Do.call(t)]}function xt(t,n,r,e,o,u){var i=Ur(t),c=Ur(n),a=Co,f=Co;i||(a=fo(t),a=a==Uo?Ro:a),c||(f=fo(n),f=f==Uo?Ro:f);var l=a==Ro&&!X(t),s=f==Ro&&!X(n),p=a==f;if(p&&!l)return u||(u=new gt),i||Lt(t)?wt(t,n,r,e,o,u):kt(t,n,a,r,e,o,u);if(!(o&Bo)){var h=l&&Wo.call(t,"__wrapped__"),v=s&&Wo.call(n,"__wrapped__");if(h||v){var y=h?t.value():t,d=v?n.value():n;return u||(u=new gt),r(y,d,e,o,u)}}return p?(u||(u=new gt),Et(t,n,r,e,o,u)):!1}function It(t,n,e,u,i){return t===n?!0:null==t||null==n||!r(t)&&!o(n)?t!==t&&n!==n:xt(t,n,It,e,u,i)}function Tt(t,n,r,e){var o=r.length,u=o,i=!e;if(null==t)return!u;for(t=Object(t);o--;){var c=r[o];if(i&&c[2]?c[1]!==t[c[0]]:!(c[0]in t))return!1}for(;++o<u;){c=r[o];var a=c[0],f=t[a],l=c[1];if(i&&c[2]){if(void 0===f&&!(a in t))return!1}else{var s=new gt;if(e)var p=e(f,l,a,t,n,s);if(!(void 0===p?It(l,f,e,No|Vo,s):p))return!1}}return!0}function Mt(t){return t===t&&!r(t)}function $t(t,n){for(var r=-1,e=t.length,o=Array(e);++r<e;)o[r]=n(t[r],r,t);return o}function zt(t,n){return $t(n,function(n){return[n,t[n]]})}function Ft(t){var n=-1,r=Array(t.size);return t.forEach(function(t){r[++n]=[t,t]}),r}function Pt(t){return function(n){var r=fo(n);return r==Qo?St(n):r==Go?Ft(n):zt(n,t(n))}}function Dt(t){for(var n=Ho(t),r=n.length;r--;)n[r][2]=Mt(n[r][1]);return n}function Bt(t,n){return function(r){return null==r?!1:r[t]===n&&(void 0!==n||t in Object(r))}}function Ut(t){var n=Dt(t);return 1==n.length&&n[0][2]?Bt(n[0][0],n[0][1]):function(r){return r===t||Tt(r,t,n)}}function Ct(t,n){if("function"!=typeof t||n&&"function"!=typeof n)throw new TypeError(Jo);var r=function(){var e=arguments,o=n?n.apply(this,e):e[0],u=r.cache;if(u.has(o))return u.get(o);var i=t.apply(this,e);return r.cache=u.set(o,i),i};return r.cache=new(Ct.Cache||yt),r}function Rt(t){if("string"==typeof t)return t;if(u(t))return Zo?Zo.call(t):"";var n=t+"";return"0"==n&&1/t==-Xo?"-0":n}function qt(t){return null==t?"":Rt(t)}function Wt(t){return Ur(t)?t:ru(t)}function Nt(t,n){if(Ur(t))return!1;var r=typeof t;return"number"==r||"symbol"==r||"boolean"==r||null==t||u(t)?!0:ou.test(t)||!eu.test(t)||null!=n&&t in Object(n)}function Vt(t){if("string"==typeof t||u(t))return t;var n=t+"";return"0"==n&&1/t==-uu?"-0":n}function Qt(t,n){n=Nt(n,t)?[n]:Wt(n);for(var r=0,e=n.length;null!=t&&e>r;)t=t[Vt(n[r++])];return r&&r==e?t:void 0}function Gt(t,n,r){var e=null==t?void 0:Qt(t,n);return void 0===e?r:e}function Ht(t,n){return n in Object(t)}function Jt(t,n,r){n=Nt(n,t)?[n]:Wt(n);for(var e,o=-1,u=n.length;++o<u;){var i=Vt(n[o]);if(!(e=null!=t&&r(t,i)))break;t=t[i]}if(e)return e;var u=t?t.length:0;return!!u&&y(u)&&E(i,u)&&(Ur(t)||O(t)||S(t))}function Kt(t,n){return null!=t&&Jt(t,n,Ht)}function Xt(t,n){return Nt(t)&&Mt(n)?Bt(Vt(t),n):function(r){var e=Gt(r,t);return void 0===e&&e===n?Kt(r,t):It(n,e,void 0,iu|cu)}}function Yt(t){return t}function Zt(t){return function(n){return Qt(n,t)}}function tn(t){return Nt(t)?v(Vt(t)):Zt(t)}function nn(t){return"function"==typeof t?t:null==t?Yt:"object"==typeof t?Ur(t)?Xt(t[0],t[1]):Ut(t):tn(t)}function rn(t,n){return t&&B(t,nn(n,3))}function en(t,n,r){for(var e=t.length,o=n+(r?0:-1);r?o--:++o<e;){var u=t[o];if(u!==u)return o}return-1}function on(t,n,r){if(n!==n)return en(t,r);for(var e=r-1,o=t.length;++e<o;)if(t[e]===n)return e;return-1}function un(t,n,r){function e(t,n){b.push(function(){c(t,n)})}function o(){if(0===b.length&&0===d)return r(null,y);for(;b.length&&n>d;){var t=b.shift();t()}}function u(t,n){var r=m[t];r||(r=m[t]=[]),r.push(n)}function i(t){var n=m[t]||[];P(n,function(t){t()}),o()}function c(t,n){if(!g){var e=I(f(function(n,e){if(d--,e.length<=1&&(e=e[0]),n){var o={};rn(y,function(t,n){o[n]=t}),o[t]=e,g=!0,m=[],r(n,o)}else y[t]=e,i(t)}));d++;var o=n[n.length-1];n.length>1?o(y,e):o(e)}}function a(){for(var t,n=0;_.length;)t=_.pop(),n++,P(l(t),function(t){--j[t]||_.push(t)});if(n!==v)throw new Error("async.auto cannot execute tasks due to a recursive dependency")}function l(n){var r=[];return rn(t,function(t,e){Ur(t)&&on(t,n,0)>=0&&r.push(e)}),r}"function"==typeof n&&(r=n,n=null),r=h(r||p);var s=L(t),v=s.length;if(!v)return r(null);n||(n=v);var y={},d=0,g=!1,m={},b=[],_=[],j={};rn(t,function(n,r){if(!Ur(n))return e(r,[n]),void _.push(r);var o=n.slice(0,n.length-1),i=o.length;return 0===i?(e(r,n),void _.push(r)):(j[r]=i,void P(o,function(c){if(!t[c])throw new Error("async.auto task `"+r+"` has a non-existent dependency in "+o.join(", "));u(c,function(){i--,0===i&&e(r,n)})}))}),a(),o()}function cn(t,n){var r=-1,e=t.length;for(n||(n=Array(e));++r<e;)n[r]=t[r];return n}function an(t,n,r){var e=-1,o=t.length;0>n&&(n=-n>o?0:o+n),r=r>o?o:r,0>r&&(r+=o),o=n>r?0:r-n>>>0,n>>>=0;for(var u=Array(o);++e<o;)u[e]=t[e+n];return u}function fn(t,n,r){var e=t.length;return r=void 0===r?e:r,!n&&r>=e?t:an(t,n,r)}function ln(t,n){for(var r=t.length;r--&&on(n,t[r],0)>-1;);return r}function sn(t,n){for(var r=-1,e=t.length;++r<e&&on(n,t[r],0)>-1;);return r}function pn(t){return t.match(ku)}function hn(t,n,r){if(t=qt(t),t&&(r||void 0===n))return t.replace(Eu,"");if(!t||!(n=Rt(n)))return t;var e=pn(t),o=pn(n),u=sn(e,o),i=ln(e,o)+1;return fn(e,u,i).join("")}function vn(t){return hn(t.toString().match(Au)[2]).split(/\s*\,\s*/)}function yn(t,n){var r={};rn(t,function(t,n){function e(n,r){var e=$t(o,function(t){return n[t]});e.push(r),t.apply(null,e)}var o;if(Ur(t))o=cn(t),t=o.pop(),r[n]=o.concat(o.length>0?e:t);else{if(0===t.length)throw new Error("autoInject task functions require explicit parameters.");1===t.length?r[n]=t:(o=vn(t),o.pop(),r[n]=o.concat(e))}}),un(r,n)}function dn(t,n,r){function e(t,n,r,e){if(null!=e&&"function"!=typeof e)throw new Error("task callback must be a function");return t.started=!0,Ur(n)||(n=[n]),0===n.length&&t.idle()?xu(function(){t.drain()}):(P(n,function(n){var o={data:n,callback:e||p};r?t.tasks.unshift(o):t.tasks.push(o)}),void xu(t.process))}function o(t,n){return function(){u-=1;var r=!1,e=arguments;P(n,function(t){P(i,function(n,e){n!==t||r||(i.splice(e,1),r=!0)}),t.callback.apply(t,e)}),u<=t.concurrency-t.buffer&&t.unsaturated(),t.tasks.length+u===0&&t.drain(),t.process()}}if(null==n)n=1;else if(0===n)throw new Error("Concurrency must not be zero");var u=0,i=[],c={tasks:[],concurrency:n,payload:r,saturated:p,unsaturated:p,buffer:n/4,empty:p,drain:p,started:!1,paused:!1,push:function(t,n){e(c,t,!1,n)},kill:function(){c.drain=p,c.tasks=[]},unshift:function(t,n){e(c,t,!0,n)},process:function(){for(;!c.paused&&u<c.concurrency&&c.tasks.length;){var n=c.payload?c.tasks.splice(0,c.payload):c.tasks.splice(0,c.tasks.length),r=$t(n,v("data"));0===c.tasks.length&&c.empty(),u+=1,i.push(n[0]),u===c.concurrency&&c.saturated();var e=I(o(c,n));t(r,e)}},length:function(){return c.tasks.length},running:function(){return u},workersList:function(){return i},idle:function(){return c.tasks.length+u===0},pause:function(){c.paused=!0},resume:function(){if(c.paused!==!1){c.paused=!1;for(var t=Math.min(c.concurrency,c.tasks.length),n=1;t>=n;n++)xu(c.process)}}};return c}function gn(t,n){return dn(t,1,n)}function mn(t,n,r,e){T(n)(t,r,e)}function bn(t,n,r,e){Iu(t,function(t,e,o){r(n,t,function(t,r){n=r,o(t)})},function(t){e(t,n)})}function _n(){var t=arguments;return f(function(n){var r=this,e=n[n.length-1];"function"==typeof e?n.pop():e=p,bn(t,n,function(t,n,e){n.apply(r,t.concat([f(function(t,n){e(t,n)})]))},function(t,n){e.apply(r,[t].concat(n))})})}function jn(){return _n.apply(null,Tu.call(arguments))}function wn(t,n,r,e){var o=[];t(n,function(t,n,e){r(t,function(t,n){o=o.concat(n||[]),e(t)})},function(t){e(t,o)})}function Sn(t){return function(n,r,e){return t(Mu,n,r,e)}}function On(t){return function(n,r,e){return t(Iu,n,r,e)}}function kn(t,n,r){return function(e,o,u,i){function c(t){i&&(t?i(t):i(null,r(!1)))}function a(t,e,o){return i?void u(t,function(e,c){i&&(e?(i(e),i=u=!1):n(c)&&(i(null,r(!0,t)),i=u=!1)),o()}):o()}arguments.length>3?(i=i||p,t(e,o,a,c)):(i=u,i=i||p,u=o,t(e,a,c))}}function En(t,n){return n}function An(t){return f(function(n,r){n.apply(null,r.concat([f(function(n,r){"object"==typeof console&&(n?console.error&&console.error(n):console[t]&&P(r,function(n){console[t](n)}))})]))})}function Ln(t,n,r){r=r||p;var e=f(function(n,e){n?r(n):(e.push(o),t.apply(this,e))}),o=function(t,o){return t?r(t):o?void n(e):r(null)};t(o)}function xn(t,n,r){var e=0;Ln(function(t){return e++<1?t(null,!0):void n.apply(this,arguments)},t,r)}function In(t,n,r){if(r=r||p,!t())return r(null);var e=f(function(o,u){return o?r(o):t.apply(this,u)?n(e):void r.apply(null,[null].concat(u))});n(e)}function Tn(t,n,r){var e=0;return In(function(){return++e<=1||n.apply(this,arguments)},t,r)}function Mn(t,n,r){return Tn(t,function(){return!n.apply(this,arguments)},r)}function $n(t){return function(n,r,e){return t(n,e)}}function zn(t,n,r,e){return T(n)(t,$n(r),e)}function Fn(t){return l(function(n,r){var e=!0;n.push(function(){var t=arguments;e?xu(function(){r.apply(null,t)}):r.apply(null,t)}),t.apply(this,n),e=!1})}function Pn(t){return!t}function Dn(t,n,r,e){var o=[];t(n,function(t,n,e){r(t,function(r,u){r?e(r):(u&&o.push({index:n,value:t}),e())})},function(t){t?e(t):e(null,$t(o.sort(function(t,n){return t.index-n.index}),v("value")))})}function Bn(t,n){function r(t){return t?e(t):void o(r)}var e=I(n||p),o=Fn(t);r()}function Un(t){function n(r){function e(){return t.length&&t[r].apply(null,arguments),e.next()}return e.next=function(){return r<t.length-1?n(r+1):null},e}return n(0)}function Cn(t,n){return n in t}function Rn(t,n){var r=Object.create(null),e=Object.create(null);n=n||Yt;var o=l(function(o,u){var i=n.apply(null,o);Cn(r,i)?xu(function(){u.apply(null,r[i])}):Cn(e,i)?e[i].push(u):(e[i]=[u],t.apply(null,o.concat([f(function(t){r[i]=t;var n=e[i];delete e[i];for(var o=0,u=n.length;u>o;o++)n[o].apply(null,t)})])))});return o.memo=r,o.unmemoized=t,o}function qn(t,n,r){r=r||p;var e=d(n)?[]:{};t(n,function(t,n,r){t(f(function(t,o){o.length<=1&&(o=o[0]),e[n]=o,r(t)}))},function(t){r(t,e)})}function Wn(t,n,r){return qn(T(n),t,r)}function Nn(t,n){return dn(function(n,r){t(n[0],r)},n,1)}function Vn(t,n){function r(t,n){return t.priority-n.priority}function e(t,n,r){for(var e=-1,o=t.length-1;o>e;){var u=e+(o-e+1>>>1);r(n,t[u])>=0?e=u:o=u-1}return e}function o(t,n,o,u){if(null!=u&&"function"!=typeof u)throw new Error("task callback must be a function");return t.started=!0,Ur(n)||(n=[n]),0===n.length?xu(function(){t.drain()}):void P(n,function(n){var i={data:n,priority:o,callback:"function"==typeof u?u:p};t.tasks.splice(e(t.tasks,i,r)+1,0,i),xu(t.process)})}var u=Nn(t,n);return u.push=function(t,n,r){o(u,t,n,r)},delete u.unshift,u}function Qn(t,n){return function(r,e){if(null==r)return r;if(!d(r))return t(r,e);for(var o=r.length,u=n?o:-1,i=Object(r);(n?u--:++u<o)&&e(i[u],u,i)!==!1;);return r}}function Gn(t,n){var r=Ur(t)?P:Ku;return r(t,nn(n,3))}function Hn(t,n){return n=h(n||p),Ur(t)?t.length?void Gn(t,function(t){t(n)}):n():n(new TypeError("First argument to race must be an array of functions"))}function Jn(t,n,r,e){var o=Xu.call(t).reverse();bn(o,n,r,e)}function Kn(t){return l(function(n,r){return n.push(f(function(t,n){if(t)r(null,{error:t});else{var e=null;1===n.length?e=n[0]:n.length>1&&(e=n),r(null,{value:e})}})),t.apply(this,n)})}function Xn(t,n,r,e){Dn(t,n,function(t,n){r(t,function(t,r){t?n(t):n(null,!r)})},e)}function Yn(t){return t.map(Kn)}function Zn(t,n){return qn(Iu,t,n)}function tr(t,n,r){function e(t,n){if("object"==typeof n)t.times=+n.times||i,t.interval=+n.interval||c;else{if("number"!=typeof n&&"string"!=typeof n)throw new Error("Invalid arguments for async.retry");t.times=+n||i}}function o(t){return function(r){n(function(n,e){r(!n||t,{err:n,result:e})})}}function u(t){return function(n){setTimeout(function(){n(null)},t)}}var i=5,c=0,a={times:i,interval:c};if(arguments.length<3&&"function"==typeof t?(r=n||p,n=t):(e(a,t),r=r||p),"function"!=typeof n)throw new Error("Invalid arguments for async.retry");for(var f=[];a.times;){var l=!(a.times-=1);f.push(o(l)),!l&&a.interval>0&&f.push(u(a.interval))}Zn(f,function(t,n){n=n[n.length-1],r(n.err,n.result)})}function nr(t,n){return n||(n=t,t=null),l(function(r,e){function o(t){n.apply(null,r.concat([t]))}t?tr(t,o,e):tr(o,e)})}function rr(t,n,r){function e(t,n){var r=t.criteria,e=n.criteria;return e>r?-1:r>e?1:0}Gr(t,function(t,r){n(t,function(n,e){return n?r(n):void r(null,{value:t,criteria:e})})},function(t,n){return t?r(t):void r(null,$t(n.sort(e),v("value")))})}function er(t,n,r){function e(){c||(u.apply(null,arguments),clearTimeout(i))}function o(){var n=t.name||"anonymous",e=new Error('Callback function "'+n+'" timed out.');e.code="ETIMEDOUT",r&&(e.info=r),c=!0,u(e)}var u,i,c=!1;return l(function(r,c){u=c,i=setTimeout(o,n),t.apply(null,r.concat(e))})}function or(t,n,r,e){for(var o=-1,u=ui(oi((n-t)/(r||1)),0),i=Array(u);u--;)i[e?u:++o]=t,t+=r;return i}function ur(t,n,r,e){return Qr(or(0,t,1),n,r,e)}function ir(t,n,r,e){3===arguments.length&&(e=r,r=n,n=Ur(t)?[]:{}),Mu(t,function(t,e,o){r(n,t,e,o)},function(t){e(t,n)})}function cr(t){return function(){return(t.unmemoized||t).apply(null,arguments)}}function ar(t,n,r){return In(function(){return!t.apply(this,arguments)},n,r)}function fr(t,n){function r(o){if(e===t.length)return n.apply(null,[null].concat(o));var u=I(f(function(t,e){return t?n.apply(null,[t].concat(e)):void r(e)}));o.push(u);var i=t[e++];i.apply(null,o)}if(n=h(n||p),!Ur(t))return n(new Error("First argument to waterfall must be an array of functions"));if(!t.length)return n();var e=0;r([])}var lr="[object Function]",sr="[object GeneratorFunction]",pr=Object.prototype,hr=pr.toString,vr="[object Symbol]",yr=Object.prototype,dr=yr.toString,gr=NaN,mr=/^\s+|\s+$/g,br=/^[-+]0x[0-9a-f]+$/i,_r=/^0b[01]+$/i,jr=/^0o[0-7]+$/i,wr=parseInt,Sr=1/0,Or=1.7976931348623157e308,kr="Expected a function",Er=Math.max,Ar=v("length"),Lr=9007199254740991,xr="function"==typeof Symbol&&Symbol.iterator,Ir=Object.getPrototypeOf,Tr=Object.prototype,Mr=Tr.hasOwnProperty,$r=Object.keys,zr="[object Arguments]",Fr=Object.prototype,Pr=Fr.hasOwnProperty,Dr=Fr.toString,Br=Fr.propertyIsEnumerable,Ur=Array.isArray,Cr="[object String]",Rr=Object.prototype,qr=Rr.toString,Wr=9007199254740991,Nr=/^(?:0|[1-9]\d*)$/,Vr=Object.prototype,Qr=M($),Gr=z(Qr,1/0),Hr=s(Gr),Jr=z(Qr,1),Kr=s(Jr),Xr=f(function(t,n){return f(function(r){return t.apply(null,n.concat(r))})}),Yr=D(),Zr=Array.prototype,te=Zr.splice;Q.prototype.clear=U,Q.prototype["delete"]=q,Q.prototype.get=W,Q.prototype.has=N,Q.prototype.set=V;var ne=Function.prototype.toString,re=/[\\^$.*+?()[\]{}|]/g,ee=/^\[object .+?Constructor\]$/,oe=Object.prototype,ue=Function.prototype.toString,ie=oe.hasOwnProperty,ce=RegExp("^"+ue.call(ie).replace(re,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ae=tt(Object,"create"),fe="__lodash_hash_undefined__",le=Object.prototype,se=le.hasOwnProperty,pe=Object.prototype,he=pe.hasOwnProperty,ve="__lodash_hash_undefined__";it.prototype.clear=nt,it.prototype["delete"]=rt,it.prototype.get=et,it.prototype.has=ot,it.prototype.set=ut;var ye={"function":!0,object:!0},de=ye[typeof t]&&t&&!t.nodeType?t:void 0,ge=ye[typeof module]&&module&&!module.nodeType?module:void 0,me=ct(de&&ge&&"object"==typeof global&&global),be=ct(ye[typeof self]&&self),_e=ct(ye[typeof window]&&window),je=ct(ye[typeof this]&&this),we=me||_e!==(je&&je.window)&&_e||be||je||Function("return this")(),Se=tt(we,"Map");yt.prototype.clear=at,yt.prototype["delete"]=st,yt.prototype.get=pt,yt.prototype.has=ht,yt.prototype.set=vt;var Oe=200;gt.prototype.clear=G,gt.prototype["delete"]=H,gt.prototype.get=J,gt.prototype.has=K,gt.prototype.set=dt;var ke="__lodash_hash_undefined__";_t.prototype.add=_t.prototype.push=mt,_t.prototype.has=bt;var Ee=1,Ae=2,Le=we.Symbol,xe=we.Uint8Array,Ie=1,Te=2,Me="[object Boolean]",$e="[object Date]",ze="[object Error]",Fe="[object Map]",Pe="[object Number]",De="[object RegExp]",Be="[object Set]",Ue="[object String]",Ce="[object Symbol]",Re="[object ArrayBuffer]",qe="[object DataView]",We=Le?Le.prototype:void 0,Ne=We?We.valueOf:void 0,Ve=2,Qe=tt(we,"DataView"),Ge=tt(we,"Promise"),He=tt(we,"Set"),Je=tt(we,"WeakMap"),Ke="[object Map]",Xe="[object Object]",Ye="[object Promise]",Ze="[object Set]",to="[object WeakMap]",no="[object DataView]",ro=Object.prototype,eo=ro.toString,oo=Y(Qe),uo=Y(Se),io=Y(Ge),co=Y(He),ao=Y(Je);(Qe&&At(new Qe(new ArrayBuffer(1)))!=no||Se&&At(new Se)!=Ke||Ge&&At(Ge.resolve())!=Ye||He&&At(new He)!=Ze||Je&&At(new Je)!=to)&&(At=function(t){var n=eo.call(t),r=n==Xe?t.constructor:void 0,e=r?Y(r):void 0;if(e)switch(e){case oo:return no;case uo:return Ke;case io:return Ye;case co:return Ze;case ao:return to}return n});var fo=At,lo="[object Arguments]",so="[object Array]",po="[object Boolean]",ho="[object Date]",vo="[object Error]",yo="[object Function]",go="[object Map]",mo="[object Number]",bo="[object Object]",_o="[object RegExp]",jo="[object Set]",wo="[object String]",So="[object WeakMap]",Oo="[object ArrayBuffer]",ko="[object DataView]",Eo="[object Float32Array]",Ao="[object Float64Array]",Lo="[object Int8Array]",xo="[object Int16Array]",Io="[object Int32Array]",To="[object Uint8Array]",Mo="[object Uint8ClampedArray]",$o="[object Uint16Array]",zo="[object Uint32Array]",Fo={};Fo[Eo]=Fo[Ao]=Fo[Lo]=Fo[xo]=Fo[Io]=Fo[To]=Fo[Mo]=Fo[$o]=Fo[zo]=!0,Fo[lo]=Fo[so]=Fo[Oo]=Fo[po]=Fo[ko]=Fo[ho]=Fo[vo]=Fo[yo]=Fo[go]=Fo[mo]=Fo[bo]=Fo[_o]=Fo[jo]=Fo[wo]=Fo[So]=!1;var Po=Object.prototype,Do=Po.toString,Bo=2,Uo="[object Arguments]",Co="[object Array]",Ro="[object Object]",qo=Object.prototype,Wo=qo.hasOwnProperty,No=1,Vo=2,Qo="[object Map]",Go="[object Set]",Ho=Pt(L),Jo="Expected a function";Ct.Cache=yt;var Ko,Xo=1/0,Yo=Le?Le.prototype:void 0,Zo=Yo?Yo.toString:void 0,tu=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g,nu=/\\(\\)?/g,ru=Ct(function(t){var n=[];return qt(t).replace(tu,function(t,r,e,o){n.push(e?o.replace(nu,"$1"):r||t)}),n}),eu=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,ou=/^\w*$/,uu=1/0,iu=1,cu=2,au="\\ud800-\\udfff",fu="\\u0300-\\u036f\\ufe20-\\ufe23",lu="\\u20d0-\\u20f0",su="\\ufe0e\\ufe0f",pu="["+au+"]",hu="["+fu+lu+"]",vu="\\ud83c[\\udffb-\\udfff]",yu="(?:"+hu+"|"+vu+")",du="[^"+au+"]",gu="(?:\\ud83c[\\udde6-\\uddff]){2}",mu="[\\ud800-\\udbff][\\udc00-\\udfff]",bu="\\u200d",_u=yu+"?",ju="["+su+"]?",wu="(?:"+bu+"(?:"+[du,gu,mu].join("|")+")"+ju+_u+")*",Su=ju+_u+wu,Ou="(?:"+[du+hu+"?",hu,gu,mu,pu].join("|")+")",ku=RegExp(vu+"(?="+vu+")|"+Ou+Su,"g"),Eu=/^\s+|\s+$/g,Au=/^(function[^\(]*)?\(?\s*([^\)=]*)/m,Lu="function"==typeof setImmediate&&setImmediate;Ko=Lu?Lu:"object"==typeof process&&"function"==typeof process.nextTick?process.nextTick:function(t){setTimeout(t,0)};var xu=f(function(t,n){Ko(function(){t.apply(null,n)})}),Iu=z(mn,1),Tu=Array.prototype.reverse,Mu=z(mn,1/0),$u=Sn(wn),zu=On(wn),Fu=f(function(t){var n=[null].concat(t);return l(function(t,r){return r.apply(this,n)})}),Pu=kn(Mu,Yt,En),Du=kn(mn,Yt,En),Bu=kn(Iu,Yt,En),Uu=An("dir"),Cu=z(zn,1/0),Ru=z(zn,1),qu=kn(mn,Pn,Pn),Wu=z(qu,1/0),Nu=z(qu,1),Vu=M(Dn),Qu=z(Vu,1/0),Gu=z(Vu,1),Hu=An("log"),Ju=z(Wn,1/0),Ku=Qn(B),Xu=Array.prototype.slice,Yu=M(Xn),Zu=z(Yu,1/0),ti=z(Yu,1),ni=kn(mn,Boolean,Yt),ri=z(ni,1/0),ei=z(ni,1),oi=Math.ceil,ui=Math.max,ii=z(ur,1/0),ci=z(ur,1),ai={applyEach:Hr,applyEachSeries:Kr,apply:Xr,asyncify:F,auto:un,autoInject:yn,cargo:gn,compose:jn,concat:$u,concatSeries:zu,constant:Fu,detect:Pu,detectLimit:Du,detectSeries:Bu,dir:Uu,doDuring:xn,doUntil:Mn,doWhilst:Tn,during:Ln,each:Cu,eachLimit:zn,eachOf:Mu,eachOfLimit:mn,eachOfSeries:Iu,eachSeries:Ru,ensureAsync:Fn,every:Wu,everyLimit:qu,everySeries:Nu,filter:Qu,filterLimit:Vu,filterSeries:Gu,forever:Bn,iterator:Un,log:Hu,map:Gr,mapLimit:Qr,mapSeries:Jr,memoize:Rn,nextTick:xu,parallel:Ju,parallelLimit:Wn,priorityQueue:Vn,queue:Nn,race:Hn,reduce:bn,reduceRight:Jn,reflect:Kn,reflectAll:Yn,reject:Zu,rejectLimit:Yu,rejectSeries:ti,retry:tr,retryable:nr,seq:_n,series:Zn,setImmediate:xu,some:ri,someLimit:ni,someSeries:ei,sortBy:rr,timeout:er,times:ii,timesLimit:ur,timesSeries:ci,transform:ir,unmemoize:cr,until:ar,waterfall:fr,whilst:In,all:Wu,any:ri,forEach:Cu,forEachSeries:Ru,forEachLimit:zn,forEachOf:Mu,forEachOfSeries:Iu,forEachOfLimit:mn,inject:bn,foldl:bn,foldr:Jn,select:Qu,selectLimit:Vu,selectSeries:Gu,wrapSync:F};t["default"]=ai,t.applyEach=Hr,t.applyEachSeries=Kr,t.apply=Xr,t.asyncify=F,t.auto=un,t.autoInject=yn,t.cargo=gn,t.compose=jn,t.concat=$u,t.concatSeries=zu,t.constant=Fu,t.detect=Pu,t.detectLimit=Du,t.detectSeries=Bu,t.dir=Uu,t.doDuring=xn,t.doUntil=Mn,t.doWhilst=Tn,t.during=Ln,t.each=Cu,t.eachLimit=zn,t.eachOf=Mu,t.eachOfLimit=mn,t.eachOfSeries=Iu,t.eachSeries=Ru,t.ensureAsync=Fn,t.every=Wu,t.everyLimit=qu,t.everySeries=Nu,t.filter=Qu,t.filterLimit=Vu,t.filterSeries=Gu,t.forever=Bn,t.iterator=Un,t.log=Hu,t.map=Gr,t.mapLimit=Qr,t.mapSeries=Jr,t.memoize=Rn,t.nextTick=xu,t.parallel=Ju,t.parallelLimit=Wn,t.priorityQueue=Vn,t.queue=Nn,t.race=Hn,t.reduce=bn,t.reduceRight=Jn,t.reflect=Kn,t.reflectAll=Yn,t.reject=Zu,t.rejectLimit=Yu,t.rejectSeries=ti,t.retry=tr,t.retryable=nr,t.seq=_n,t.series=Zn,t.setImmediate=xu,t.some=ri,t.someLimit=ni,t.someSeries=ei,t.sortBy=rr,t.timeout=er,t.times=ii,t.timesLimit=ur,t.timesSeries=ci,t.transform=ir,t.unmemoize=cr,t.until=ar,t.waterfall=fr,t.whilst=In,t.all=Wu,t.allLimit=qu,t.allSeries=Nu,t.any=ri,t.anyLimit=ni,t.anySeries=ei,t.find=Pu,t.findLimit=Du,t.findSeries=Bu,t.forEach=Cu,t.forEachSeries=Ru,t.forEachLimit=zn,t.forEachOf=Mu,t.forEachOfSeries=Iu,t.forEachOfLimit=mn,t.inject=bn,t.foldl=bn,t.foldr=Jn,t.select=Qu,t.selectLimit=Vu,t.selectSeries=Gu,t.wrapSync=F});
app.factory('live', ['$http','$rootScope',
    function($http, $rootScope){    
   
        var obj = {};

        obj.getCameras = function(success, error){
            $http.get('/cameras')
                .then(success, error);
        };

        obj.getLiveImage = function(serverId, camId, success, error){
            console.log('fetching live image')
            $http.get('/cameras/' + serverId + '/' + camId + '/live')
                .then(success, error);
        };

        return obj;
}]);

app.controller('livecontroller', ["$scope", '$rootScope', '$window', "live", "device", "$interval", "$translate", function($scope, $rootScope, $window, live, device, $interval, $translate) {
    
    $scope.selectedcamera = undefined;

    $scope.device = device;

    $scope.selectedcamera = undefined;

    live.getCameras(function success(response){
        console.log(response);
        if (response.status === 204){ // empty result, no cameras
            $scope.cameras = undefined;
        } else {
            $scope.cameras = response.data;
        }
        for (var site in $scope.cameras){
            $scope.cameras[site].forEach(function(cam){
                live.getLiveImage(cam.serverId, cam.id, function success(response){
                    cam.image = 'data:image/jpeg;base64,' + response.data;
                }, function error(response){
                    cam.image = '/img/no_video.png';
                    $scope.logHttpError(response);
                });
            });
        }
    }, function error(response){
        $scope.logHttpError(response);
        $scope.sendnotification("NOTIF_ERROR_GETTING_CAMERAS", 
            false, 
            1);
    });


    $scope.playfullscreen = function(site, camera){
        if (site && camera){
            $scope.selectedcamera = {
                site: site,
                camera: camera
            };
        } else {
            $scope.selectedcamera = undefined;
        }
    };

    $scope.shownextcamera = function(){
        if ($scope.selectedcamera){
            var currentSite = $scope.selectedcamera.site;
            var index;
            $scope.cameras[currentSite].some(function(camera, i){
                if (camera.id === $scope.selectedcamera.camera.id && camera.serverId === $scope.selectedcamera.camera.serverId){
                    index = i;
                    return true;
                } else {
                    return false;
                }
            });
            index++;
            if (index >= $scope.cameras[currentSite].length){
                index = 0;
            }
            $scope.selectedcamera.camera = $scope.cameras[currentSite][index];
        }
    }

    $scope.showpreviouscamera = function(){
        if ($scope.selectedcamera){
            var currentSite = $scope.selectedcamera.site;
            var index = $scope.cameras[currentSite].map(function(c){ return c.id }).indexOf($scope.selectedcamera.camera.id);
            index--;
            if (index < 0){
                index = $scope.cameras[currentSite].length - 1;
            }
            $scope.selectedcamera.camera = $scope.cameras[currentSite][index];
        }
    }

}]);

app.directive('liveplayer', ["live", "$interval", "device", function(live, $interval, device){
    return {
        restrict: 'E',
        replace: true,
        templateUrl: '/liveplayer',
        // "pause" is set to true when a camera is selected for fullscreen : we don't want 
        // to stop playing completely, so that when fullscreen is closed, playing resumes
        scope: {site: "=", camera: "=", pause: "=", playfullscreen: '&', fullscreen: '=', help: '='},
        link: function(scope, elem, attrs){
            scope.showcontrols = true;
            scope.playing = undefined;
            scope.togglelivefeed = function(){
                elem.find('.big-playing-indicator').show().fadeOut(500);

                if (!scope.playing){
                    scope.playing = $interval(function(){
                        if (!scope.pause){
                            live.getLiveImage(scope.camera.serverId, scope.camera.id, function success(response){
                                scope.camera.image = 'data:image/jpeg;base64,' + response.data;
                            }, function error(response){
                                scope.logHttpError(response);
                                scope.camera.image = '/img/no_video.png';
                            });
                        }
                    }, 200);
                } else {
                    $interval.cancel(scope.playing);
                    scope.playing = undefined;
                    scope.showcontrols = true;
                }
            };

            scope.$watch('camera', function(newVal, oldVal){
                if (newVal === oldVal) return;
                if (newVal){
                    if(!scope.playing){
                        scope.togglelivefeed();
                    }
                } else if (scope.playing){
                    $interval.cancel(scope.playing);
                    scope.togglelivefeed();
                }
            });

        }
    };
}]);

app.directive('liveimage', function(){
    return {
        restrict: 'E',
        scope:{image:"="},
        replace: true,
        template: '<canvas class="imagecanvas"/>',
        link: function(scope, elem, attrs){

            var canvas = elem[0];
            canvas.setAttribute('width', 800);
            canvas.setAttribute('height', 600);

            function repaintImage(){
                var image = new Image();
                image.src = scope.image;

                image.onload = function(){

                    if (image 
                        && image.naturalWidth 
                        && image.naturalWidth > 0 
                        && image.naturalHeight > 0){

                        var ctx = canvas.getContext("2d");
                        ctx.width = 800;
                        ctx.height = 600;

                        var hRatio = ctx.width / image.naturalWidth;
                        var vRatio = ctx.height / image.naturalHeight;
                        var ratio = Math.min(hRatio, vRatio);
                        var shiftX = (ctx.width - image.naturalWidth * ratio) / 2;
                        var shiftY = (ctx.height - image.naturalHeight * ratio) / 2;
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(image, 0, 0, image.naturalWidth, image.naturalHeight,
                                                    shiftX, shiftY, image.naturalWidth * ratio, image.naturalHeight * ratio);

                    }

                }

            }
              
            scope.$watch('image', function(newVal, oldVal){
                repaintImage();
            });

        }

    };
});

app.animation('.fullscreen-animation', function (){
    return {
        enter: function (element, done) {
            element.hide();
            element.fadeIn(done);
        },

        leave: function (element, done) {
            element.fadeOut(done);
        },
    };
});
app.factory('logdb', ['$http', function($http){
    
    var obj = {};

    obj.getLog = function(success, error){
        $http.get('/log')
            .then(success, error);
    };

    obj.getOldLog = function(success, error){
        $http.get('/log/old')
            .then(success, error);
    };

    return obj;

}]);

app.controller('logcontroller', ['$scope', '$rootScope', 'logdb', '$translate', function($scope, $rootScope, logdb, $translate){

    $scope.log = '';
    $scope.oldlog = false;

    logdb.getLog(function success(response){
        $scope.log = response.data;
    }, function error(response){
        $scope.sendnotification("NOTIF_ERROR_GETTING_LOG", false, 1);
        $scope.logHttpError(response);
    });

    logdb.getOldLog(function success(response){
        if (response.status === 200){
            $scope.oldlog = response.data;
        }
    }, function error(response){
        // $scope.sendnotification("NOTIF_ERROR_GETTING_OLD_LOG", false, 1);
        $scope.logHttpError(response);
    });

}]);

app.directive('logviewer', function(){
    return {
        restrict: 'E',
        replace: true,
        scope: {log: '=', oldlog: '='},
        templateUrl: '/logviewer',
        link: function(scope, elem, attrs){
            scope.showOldLog = false;
            scope.$watch('log', function(){
                // This seems to be the right way to do it because... reasons
                elem.scrollTop(elem[0].scrollHeight);
            });
        }
    }
});







app.controller('navbarcontroller', ["$scope", '$rootScope', '$location', 'alarmevents', 'appstate', '$translate', function($scope, $rootScope, $location, alarmevents, appstate, $translate) {

    $scope.showLanguagePicker = false;
    setTimeout(function(){
        $scope.currentLanguage = $scope.getCurrentLanguage();
    }, 0);

    $scope.currentpage = $location.absUrl();

    $scope.alarmcounter = appstate.getState('alarmcounter')

    if ($scope.currentpage.indexOf('alarmview') > -1){
        $scope.alarmcounter = 0;
        appstate.saveState('alarmcounter', 0);
    }

    $scope.isActive = function(href){
        return $scope.currentpage.indexOf(href) > -1;
    };

    var unbind2 = $rootScope.$on("alarm_create", function(data){
        if ($scope.currentpage.indexOf('alarmview') === -1){
            $scope.alarmcounter += 1;
            localStorage.setItem('alarmcounter', $scope.alarmcounter);
        }
    });


    $scope.$on('$destroy', function () { unbind(); });

}]);
app.factory('serverdb', ['$http', '$rootScope', function ($http, $rootScope) {

        var obj = {};
        
        obj.getservers = function (success, error) {
            $http.get("/servers")
                .then(success, error);
        };

        obj.updateserver = function (server, success, error) {
            $http.put("/servers/" + server.id, server)
                .then(success, error);
        };

        obj.addserver = function (server, success, error) {
            $http.post("/servers", server)
                .then(success, error);
        };
                
        obj.deleteserver = function (serverid, success, error) {
            $http.delete("/servers/" + serverid)
                .then(success, error);
        };
        
        return obj;

    }]);




app.controller('servercontroller', ["$rootScope", "$scope", "$window", "serverdb", 'alarmevents', 'device', '$translate', function ($rootScope, $scope, $window, serverdb, alarmevents, device, $translate) {
        
        $scope.newserver = undefined;
        $scope.currentserver = undefined;
        $scope.servers = [];
        $scope.device = device;
        $scope.selected = undefined;

        $scope.back = function(){
            $window.location.href = '/accountsettings';
        };
        
        serverdb.getservers(function success(response){
            $scope.servers = response.data;
        }, function error(response){
            $scope.logHttpError(response);
            $scope.sendnotification("NOTIF_ERROR_GETTING_SERVER_LIST", 
                    false, 
                    1);        
        });
        
        $scope.initemptyserver = function () {
            $scope.resetserver();
            $scope.newserver = {
                address: "192.168.",
                port: 4000,
                username: "admin",
                password: "",
                description: ""
            };
        };

        $scope.editserver = function(serverId){
            $scope.newserver = undefined;
            // Calling this function if a server is already being edited would reset the fields
            if (!$scope.currentserver || $scope.currentserver.id !== serverId){
                var pos = $scope.servers.map(function (e) { return e.id; }).indexOf(serverId);
                $scope.currentserver = angular.copy($scope.servers[pos]);
            }
        };

        $scope.resetserver = function(){
            $scope.currentserver = undefined;
        };

        $scope.resetcurrentserver = function(){
            var pos = $scope.servers.map(function (e) { return e.id; }).indexOf($scope.currentserver.id);
            $scope.currentserver = angular.copy($scope.servers[pos]);
        }

        $scope.deleteserver = function (serverId) {
            var pos = $scope.servers.map(function (e) { return e.id; }).indexOf(serverId);
            if (pos === -1 || !$window.confirm($translate.instant("CONRIM_DELETE_SERVER"))){
                return;
            }
            serverdb.deleteserver(serverId, function success(response){
                $scope.servers.splice(pos, 1);
                $scope.sendnotification("NOTIF_SERVER_DELETED", true, 2000);
            }, function error(response){
                $scope.logHttpError(response);
                $scope.sendnotification("NOTIF_ERROR_DELETING_SERVER", 
                        false, 
                        2000); 
            });
        };

        $scope.commitcurrentserver = function(){
            if (isValidIpAddress($scope.currentserver.address)){
                serverdb.updateserver($scope.currentserver, function success(response){
                    var pos = $scope.servers.map(function (e) { return e.id; }).indexOf($scope.currentserver.id);
                    $scope.servers[pos] = $scope.currentserver;
                    $scope.resetserver();
                    $scope.sendnotification("NOTIF_SERVER_UPDATED", true, 2001);
                }, function error(response){
                    $scope.resetserver();
                    $scope.logHttpError(response);
                    $scope.sendnotification("NOTIF_ERROR_UPDATING_SERVER", 
                            false, 
                            2001);
                });
            } else {
                // Priority 2000 : should overwrite connection errors
                $scope.sendnotification("NOTIF_INVALID_IP_ADDRESS", false, 2000);
            }
        };

        $scope.commitnewserver = function(){
            if (isValidIpAddress($scope.newserver.address)){
                serverdb.addserver($scope.newserver, function success(response){
                    $scope.newserver = undefined;
                    $scope.servers.push(response.data);
                    $scope.sendnotification("NOTIF_SERVER_ADDED", true, 2001);
                }, function error(response){
                    $scope.sendnotification("NOTIF_ERROR_ADDING_SERVER" , false, 2001);
                    $scope.logHttpError(response);               
                });
            } else {
                $scope.sendnotification("NOTIF_INVALID_IP_ADDRESS", false, 2000);
            }
        };

        function isValidIpAddress(ip){
            return (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip));
        }


        $scope.getDisconnectedServers = function(){
            if ($scope.servers){
                return $scope.servers.filter(function(s){
                    return !s.connected;
                });
            } else return {};
        };


        var statusUpdate = function (event, server) {
            var pos = $scope.servers.map(function (e) { return e.id; }).indexOf(server.id);
            if (pos >= 0){
                $scope.servers[pos] = angular.copy(server);
                if (!server.connected){

                    var disconnectedServers = $scope.servers.filter(function(s){ return !s.connected; });

                    var serverList = '';
                    disconnectedServers.forEach(function(s, index){
                        serverList += '"' + s.description + '" (' + s.address + ')';
                        if (index !== disconnectedServers.length - 1){
                            serverList += ", ";
                        }
                    });
                    var params = {serverlist: serverList };
                    $scope.sendnotification("NOTIF_CONNECTION_LOST", false, 1000, params);

                } else {
                    var server = '"' + $scope.servers[pos].description + '" (' + $scope.servers[pos].address + ')';
                    $scope.sendnotification("NOTIF_CONNECTION_ESTABLISHED", true, 1000, { server: server });

                }
            }
        };
        
        var unbind = $rootScope.$on("connection", statusUpdate);
        $scope.$on('$destroy', unbind);

    }]);
// http://spin.js.org/#v2.3.2
!function(a,b){"object"==typeof module&&module.exports?module.exports=b():"function"==typeof define&&define.amd?define(b):a.Spinner=b()}(this,function(){"use strict";function a(a,b){var c,d=document.createElement(a||"div");for(c in b)d[c]=b[c];return d}function b(a){for(var b=1,c=arguments.length;c>b;b++)a.appendChild(arguments[b]);return a}function c(a,b,c,d){var e=["opacity",b,~~(100*a),c,d].join("-"),f=.01+c/d*100,g=Math.max(1-(1-a)/b*(100-f),a),h=j.substring(0,j.indexOf("Animation")).toLowerCase(),i=h&&"-"+h+"-"||"";return m[e]||(k.insertRule("@"+i+"keyframes "+e+"{0%{opacity:"+g+"}"+f+"%{opacity:"+a+"}"+(f+.01)+"%{opacity:1}"+(f+b)%100+"%{opacity:"+a+"}100%{opacity:"+g+"}}",k.cssRules.length),m[e]=1),e}function d(a,b){var c,d,e=a.style;if(b=b.charAt(0).toUpperCase()+b.slice(1),void 0!==e[b])return b;for(d=0;d<l.length;d++)if(c=l[d]+b,void 0!==e[c])return c}function e(a,b){for(var c in b)a.style[d(a,c)||c]=b[c];return a}function f(a){for(var b=1;b<arguments.length;b++){var c=arguments[b];for(var d in c)void 0===a[d]&&(a[d]=c[d])}return a}function g(a,b){return"string"==typeof a?a:a[b%a.length]}function h(a){this.opts=f(a||{},h.defaults,n)}function i(){function c(b,c){return a("<"+b+' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">',c)}k.addRule(".spin-vml","behavior:url(#default#VML)"),h.prototype.lines=function(a,d){function f(){return e(c("group",{coordsize:k+" "+k,coordorigin:-j+" "+-j}),{width:k,height:k})}function h(a,h,i){b(m,b(e(f(),{rotation:360/d.lines*a+"deg",left:~~h}),b(e(c("roundrect",{arcsize:d.corners}),{width:j,height:d.scale*d.width,left:d.scale*d.radius,top:-d.scale*d.width>>1,filter:i}),c("fill",{color:g(d.color,a),opacity:d.opacity}),c("stroke",{opacity:0}))))}var i,j=d.scale*(d.length+d.width),k=2*d.scale*j,l=-(d.width+d.length)*d.scale*2+"px",m=e(f(),{position:"absolute",top:l,left:l});if(d.shadow)for(i=1;i<=d.lines;i++)h(i,-2,"progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)");for(i=1;i<=d.lines;i++)h(i);return b(a,m)},h.prototype.opacity=function(a,b,c,d){var e=a.firstChild;d=d.shadow&&d.lines||0,e&&b+d<e.childNodes.length&&(e=e.childNodes[b+d],e=e&&e.firstChild,e=e&&e.firstChild,e&&(e.opacity=c))}}var j,k,l=["webkit","Moz","ms","O"],m={},n={lines:12,length:7,width:5,radius:10,scale:1,corners:1,color:"#000",opacity:.25,rotate:0,direction:1,speed:1,trail:100,fps:20,zIndex:2e9,className:"spinner",top:"50%",left:"50%",shadow:!1,hwaccel:!1,position:"absolute"};if(h.defaults={},f(h.prototype,{spin:function(b){this.stop();var c=this,d=c.opts,f=c.el=a(null,{className:d.className});if(e(f,{position:d.position,width:0,zIndex:d.zIndex,left:d.left,top:d.top}),b&&b.insertBefore(f,b.firstChild||null),f.setAttribute("role","progressbar"),c.lines(f,c.opts),!j){var g,h=0,i=(d.lines-1)*(1-d.direction)/2,k=d.fps,l=k/d.speed,m=(1-d.opacity)/(l*d.trail/100),n=l/d.lines;!function o(){h++;for(var a=0;a<d.lines;a++)g=Math.max(1-(h+(d.lines-a)*n)%l*m,d.opacity),c.opacity(f,a*d.direction+i,g,d);c.timeout=c.el&&setTimeout(o,~~(1e3/k))}()}return c},stop:function(){var a=this.el;return a&&(clearTimeout(this.timeout),a.parentNode&&a.parentNode.removeChild(a),this.el=void 0),this},lines:function(d,f){function h(b,c){return e(a(),{position:"absolute",width:f.scale*(f.length+f.width)+"px",height:f.scale*f.width+"px",background:b,boxShadow:c,transformOrigin:"left",transform:"rotate("+~~(360/f.lines*k+f.rotate)+"deg) translate("+f.scale*f.radius+"px,0)",borderRadius:(f.corners*f.scale*f.width>>1)+"px"})}for(var i,k=0,l=(f.lines-1)*(1-f.direction)/2;k<f.lines;k++)i=e(a(),{position:"absolute",top:1+~(f.scale*f.width/2)+"px",transform:f.hwaccel?"translate3d(0,0,0)":"",opacity:f.opacity,animation:j&&c(f.opacity,f.trail,l+k*f.direction,f.lines)+" "+1/f.speed+"s linear infinite"}),f.shadow&&b(i,e(h("#000","0 0 4px #000"),{top:"2px"})),b(d,b(i,h(g(f.color,k),"0 0 1px rgba(0,0,0,.1)")));return d},opacity:function(a,b,c){b<a.childNodes.length&&(a.childNodes[b].style.opacity=c)}}),"undefined"!=typeof document){k=function(){var c=a("style",{type:"text/css"});return b(document.getElementsByTagName("head")[0],c),c.sheet||c.styleSheet}();var o=e(a("group"),{behavior:"url(#default#VML)"});!d(o,"transform")&&o.adj?i():j=d(o,"animation")}return h});
app.factory('userdb', ['$http', '$rootScope', function($http, $rootScope){
    
    var obj = {};
        
    obj.getUsers = function (success, error) {
        $http.get('/users')
            .then(success, error);
    };

    obj.getCurrentUser = function(success, error){
        $http.get('/users/me')
            .then(success, error);
    };

    obj.updateUser = function(user, success, error){
        $http.put('/users/' + user.id, user)
            .then(success, error);
    };

    obj.updateDisplayName = function(newName, success, error){
        $http.put('/users/me/displayname', {displayname: newName})
            .then(success, error);
    };

    obj.changePassword = function(oldpasswd, newpasswd, success, error){
        $http.put('/users/me/password', {
            oldPassword: oldpasswd,
            newPassword: newpasswd
        }).then(success, error);
    };

    obj.createUser = function(user, success, error){
        $http.post('/users', user).then(success, error);
    };

    obj.requestPasswordReset = function(userId, success, callback){
        $http.post('/users/' + userId + '/resetPassword')
            .then(success, callback);
    };

    obj.deleteUser = function(userId, success, callback){
        $http.delete('/users/' + userId)
            .then(success, callback);
    };

    return obj;

}]);
app.controller('usercontroller', ["$scope",  "$window", "$location", "userdb", "$translate", function ($scope, $window, $location, userdb, $translate) {
        
        $scope.newuser = undefined;
        $scope.currentuser = undefined;
        $scope.users = [];
        $scope.device = device;

        $scope.back = function(){
            $window.location.href = '/accountsettings';
        };
   
        userdb.getUsers(function success(response){ 
            $scope.users = response.data;
        }, function error(response){
            $scope.logHttpError(response);
            $scope.sendnotification("NOTIF_ERROR_GETTING_USER_LIST", 
                    false, 
                    1);
        });

        userdb.getCurrentUser(function success(response){
            $scope.user = response.data;
        }, function error(response){
            $scope.logHttpError(response);
        });

        $scope.initemptyuser = function(){
            $scope.resetuser();
            $scope.newuser = {
                login: "",
                displayname: "",
                type: 0
            };
        };

        $scope.edituser = function(userId){
            $scope.newuser = undefined;
            // Calling this function if a user is already being edited would reset the fields
            if (!$scope.currentuser || $scope.currentuser.id !== userId){
                var pos = $scope.users.map(function (e) { return e.id; }).indexOf(userId);
                $scope.currentuser = angular.copy($scope.users[pos]);
            }
        };

        $scope.resetcurrentuser = function(){
            var pos = $scope.users.map(function (e) { return e.id; }).indexOf($scope.currentuser.id);
            $scope.currentuser = angular.copy($scope.users[pos]);
        }

        $scope.resetuser = function(){
            $scope.currentuser = undefined;
        };

        $scope.deleteuser = function (userId) {
            var pos = $scope.users.map(function (e) { return e.id; }).indexOf(userId);
            if (pos === -1 || !$window.confirm($translate.instant("CONFIRM_DELETE_USER", {username: $scope.users[pos].login}))){
                return;
            }
            userdb.deleteUser(userId, function success(response){
                $scope.users.splice(pos, 1);
                $scope.sendnotification("NOTIF_USER_DELETED", true, 1);
            }, function error(response){
                $scope.sendnotification("NOTIF_ERROR_DELETING_USER", false, 1);
                $scope.logHttpError(response);
            });
        };
        

        $scope.resetpassword = function (userId) { 
            var pos = $scope.users.map(function (e){ return e.id; }).indexOf(userId);
            if (pos === -1 || !$window.confirm($translate.instant("CONFIRM_RESET_PASSWORD", { username: $scope.users[pos].login}))){
                return;
            }
            userdb.requestPasswordReset(userId, function success(response){
                $scope.users[pos].shouldChangePassword = 1;
                $scope.sendnotification("NOTIF_PASSWORD_RESET", true, 1);
            }, function error(response){
                $scope.sendnotification("NOTIF_ERROR_RESETING_PASSWORD", false, 1);
                $scope.logHttpError(response);
            });
        };
        
        

        $scope.commitcurrentuser = function(){
            userdb.updateUser($scope.currentuser, function success(response){
                var pos = $scope.users.map(function (e) { return e.id; }).indexOf($scope.currentuser.id);
                $scope.users[pos] = $scope.currentuser;
                $scope.resetuser();
                $scope.sendnotification("NOTIF_USER_UPDATED", true, 1);
            }, function error(response){
                $scope.sendnotification("NOTIF_ERROR_UPDATING_USER" , false, 1);
                $scope.logHttpError(response);
                $scope.resetuser();
            });
        };

        $scope.commitnewuser = function(){
            userdb.createUser($scope.newuser, function success(response){
                $scope.newuser = undefined;
                console.log(response.data);
                $scope.users.push(response.data);
                console.log($scope.users);
                $scope.sendnotification("NOTIF_USER_ADDED", true, 1);
            }, function error(response){
                $scope.sendnotification("NOTIF_ERROR_ADDING_USER" , false, 1);
                $scope.logHttpError(response);
            });
        };

        // We need $index 
        $scope.getUsersExceptMe = function(me){
            if ($scope.users){
                return $scope.users.filter(function(u){
                    return u.id !== me.id;
                });
            }
        }


}]);





